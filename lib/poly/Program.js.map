{"version":3,"sources":["../../src/poly/Program.js"],"names":["Program","vertShader","fragShader","uniforms","gl","POLY","cacheAttributesLocation","cacheUniformsLocation","program","createProgram","vertS","_createShader","fragS","_attachShaders","linkProgram","getProgramParameter","LINK_STATUS","useProgram","_checkIfBasicMatrices","uniform","addUniformLocation","v","value","bind","name","getUniformLocation","undefined","matrices","i","length","create","type","_this","self","p","field_name","Object","defineProperty","get","console","log","set","new_value","getAttribLocation","addAttributeLocation","getAttributeLocation","vert","frag","attachShader","src","isVertex","shader","createShader","VERTEX_SHADER","FRAGMENT_SHADER","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog"],"mappings":"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","file":"Program.js","sourcesContent":["import { mat4 } from 'gl-matrix';\nimport UniformGroup from './UniformGroup';\nimport vert from './shaders/basic.vert';\nimport frag from './shaders/basic.frag';\n\nexport default class Program\n{\n    constructor(vertShader, fragShader, uniforms = {})\n    {\n        vertShader = vertShader || vert;\n        fragShader = fragShader || frag;\n\n        let gl = POLY.gl; // not sure that's great... :p\n        this.gl = gl;\n        // cache the locations of attributes and uniforms\n        this.cacheAttributesLocation = {}\n        this.cacheUniformsLocation = {}\n\n        // create the program itself\n        this.program = gl.createProgram();\n\n        let vertS = this._createShader(vertShader, true);\n        let fragS = this._createShader(fragShader, false);\n        this._attachShaders(vertS, fragS);\n\n        gl.linkProgram(this.program);\n\n        // check for errors\n        if (!gl.getProgramParameter(this.program, gl.LINK_STATUS))\n        {\n            throw \"Couldn't initialise program\";\n        }\n\n        gl.useProgram(this.program);\n\n        this._checkIfBasicMatrices(uniforms);\n\n        this.uniforms = new UniformGroup(uniforms, this);\n        for (let uniform in uniforms)\n        {\n            this.addUniformLocation(uniform);\n            let v = uniforms[uniform].value;\n            this.uniforms[uniform] = v;\n        }\n\n        this.bind();\n\n    }\n\n    bind()\n    {\n        this.gl.useProgram(this.program);\n    }\n\n    addUniformLocation(name)\n    {\n        this.cacheUniformsLocation[name] = this.gl.getUniformLocation(this.program, name);\n    }\n\n    getUniformLocation(name)\n    {\n        if(this.cacheUniformsLocation[name] !== undefined)\n        {\n            return this.cacheUniformsLocation[name];\n        }\n        else\n        {\n            this.addUniformLocation(name);\n\n            return this.getUniformLocation(name);\n        }\n    }\n\n    _checkIfBasicMatrices(uniforms)\n    {\n        let matrices = ['projectionMatrix', 'modelMatrix', 'viewMatrix'];\n\n        for (let i = 0; i < matrices.length; i++)\n        {\n            if(!uniforms[matrices[i]])\n            {\n                uniforms[matrices[i]] = {\n            \t\tvalue: mat4.create(),\n            \t\ttype: 'mat4'\n                }\n            }\n        }\n    }\n\n    // create a this.uniforms property\n    // useful for the setter, we can just update the uniform when it gets changed\n    _createGetterSetterUniforms(uniforms)\n    {\n        let gl = this.gl;\n        let program = this.program;\n        let _this = this;\n\n\n        let self = this;\n\n\n        this.uniforms = uniforms;\n\n        for(var p in self.uniforms) {\n\n            self.uniforms[p] = uniforms[p];\n\n            (function(field_name) {\n                Object.defineProperty (self, field_name, {\n                    get: function () {\n                        console.log('GET', field_name);\n                        return self.uniforms[field_name];\n                    },\n                    set: function (new_value) {\n                        console.log('SET', field_name, new_value);\n                        self.uniforms[field_name].value = new_value;\n                    }\n                });\n            })(p);\n        }\n\n        // for (var name in this.uniforms) {\n        //     Object.defineProperty(_this.uniforms, _name, {\n        //         get: function()\n        //         {\n        //             // if(uniforms[name])\n        //             // {\n        //             // console.log(name);\n        //                 return _this.uniforms[_name];\n        //             // }\n        //             // else {\n        //             //     console.log(\"Getting non-existant property '\" + name + \"'\");\n        //             //\n        //             //     return undefined;\n        //             // }\n        //         },\n        //         set: function(value)\n        //         {\n        //             // if(uniforms[name])\n        //             // {\n        //                 // /!\\ TODO check Wen's GLShader.uniform() when it's not a number, seems more optimised\n        //                 // uniforms[name].value = value;\n        //                 // let type = uniforms[name].type;\n        //                 // let glFunction = POLY.CONST.uniformTypes[type];\n        //                 //\n        //                 // if(type.indexOf('mat') === -1)\n        //                 // {\n        //                 //     if(type === 'texture')\n        //                 //     {\n        //                 //         gl[glFunction](_this.getUniformLocation(name), value, uniforms[name].index);\n        //                 //     }\n        //                 //     else\n        //                 //     {\n        //                 //         gl[glFunction](_this.getUniformLocation(name), value);\n        //                 //     }\n        //                 // }\n        //                 // else\n        //                 // {\n        //                 //     gl[glFunction](_this.getUniformLocation(name), false, value);\n        //                 // }\n        //\n        //                 return true;\n        //             // }\n        //         },\n        //     });\n        // }\n\n        // this.uniforms = new Proxy(uniforms, {\n        //     get: function(target, name)\n        //     {\n        //         if (!(name in target))\n        //         {\n        //             console.log(\"Getting non-existant property '\" + name + \"'\");\n        //             return undefined;\n        //         }\n        //\n        //         return target[name].value;\n        //     },\n        //     set: function(target, name, value)\n        //     {\n        //         if (!(name in target))\n        //         {\n        //             console.log(\"Setting non-existant property '\" + name + \"', initial value: \" + value);\n        //\n        //             return false;\n        //         }\n        //\n        //         // /!\\ TODO check Wen's GLShader.uniform() when it's not a number, seems more optimised\n        //         target[name].value = value;\n        //         let type = target[name].type;\n        //         let glFunction = POLY.CONST.uniformTypes[type];\n        //\n        //\n        //         if(type.indexOf('mat') === -1)\n        //         {\n        //             if(type === 'texture')\n        //             {\n        //                 gl[glFunction](_this.getUniformLocation(name), value, target[name].index);\n        //             }\n        //             else\n        //             {\n        //                 gl[glFunction](_this.getUniformLocation(name), value);\n        //             }\n        //         }\n        //         else\n        //         {\n        //             gl[glFunction](_this.getUniformLocation(name), false, value);\n        //         }\n        //\n        //         return true;\n        //     }\n        // });\n    }\n\n    addAttributeLocation(name)\n    {\n\n    //     if(shaderProgram.cacheAttribLoc === undefined) {\tshaderProgram.cacheAttribLoc = {};\t}\n\t// if(shaderProgram.cacheAttribLoc[name] === undefined) {\n\t// \tshaderProgram.cacheAttribLoc[name] = gl.getAttribLocation(shaderProgram, name);\n\t// }\n    //\n\t// return shaderProgram.cacheAttribLoc[name];\n        // console.log(this.cacheAttributesLocation[name], name);\n\n        if(this.cacheAttributesLocation[name] === undefined)\n        {\n            this.cacheAttributesLocation[name] = this.gl.getAttribLocation(this.program, name);\n        }\n    }\n\n    getAttributeLocation(name)\n    {\n        if(this.cacheAttributesLocation[name] !== undefined)\n        {\n            return this.cacheAttributesLocation[name];\n        }\n        else\n        {\n            this.addAttributeLocation(name);\n\n            return this.getAttributeLocation(name);\n        }\n    }\n\n    _attachShaders(vert, frag)\n    {\n        this.gl.attachShader(this.program, vert);\n        this.gl.attachShader(this.program, frag);\n    }\n\n    _createShader(src, isVertex)\n    {\n        let gl = this.gl;\n        let shader;\n        if (isVertex)\n        {\n            shader = gl.createShader(gl.VERTEX_SHADER);\n        }\n        else\n        {\n            shader = gl.createShader(gl.FRAGMENT_SHADER);\n        }\n\n        this.gl.shaderSource(shader, src);\n        this.gl.compileShader(shader);\n\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))\n        {\n            throw (\"Couldn't initialise shader, \", gl.getShaderInfoLog(shader));\n            return null;\n        }\n\n        return shader;\n    }\n}\n"]}