{"version":3,"sources":["../../src/poly/Program.js"],"names":["Program","vertShader","fragShader","uniforms","gl","POLY","cacheAttributesLocation","cacheUniformsLocation","program","createProgram","vertS","_createShader","fragS","_attachShaders","linkProgram","getProgramParameter","LINK_STATUS","useProgram","_checkIfBasicMatrices","_createGetterSetterUniforms","uniform","addUniformLocation","v","value","bind","name","getUniformLocation","undefined","matrices","i","length","create","type","_this","Proxy","get","target","console","log","set","glFunction","CONST","uniformTypes","indexOf","index","getAttribLocation","addAttributeLocation","getAttributeLocation","vert","frag","attachShader","src","isVertex","shader","createShader","VERTEX_SHADER","FRAGMENT_SHADER","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog"],"mappings":"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","file":"Program.js","sourcesContent":["import { mat4 } from 'gl-matrix';\r\nimport vert from './shaders/basic.vert';\r\nimport frag from './shaders/basic.frag';\r\n\r\nexport default class Program\r\n{\r\n    constructor(vertShader, fragShader, uniforms = {})\r\n    {\r\n        vertShader = vertShader || vert;\r\n        fragShader = fragShader || frag;\r\n\r\n        let gl = POLY.gl; // not sure that's great... :p\r\n        this.gl = gl;\r\n        // cache the locations of attributes and uniforms\r\n        this.cacheAttributesLocation = {}\r\n        this.cacheUniformsLocation = {}\r\n\r\n        // create the program itself\r\n        this.program = gl.createProgram();\r\n\r\n        let vertS = this._createShader(vertShader, true);\r\n        let fragS = this._createShader(fragShader, false);\r\n        this._attachShaders(vertS, fragS);\r\n\r\n        gl.linkProgram(this.program);\r\n\r\n        // check for errors\r\n        if (!gl.getProgramParameter(this.program, gl.LINK_STATUS))\r\n        {\r\n            throw \"Couldn't initialise program\";\r\n        }\r\n\r\n        gl.useProgram(this.program);\r\n\r\n        this._checkIfBasicMatrices(uniforms);\r\n        this._createGetterSetterUniforms(uniforms);\r\n        for (let uniform in uniforms)\r\n        {\r\n            this.addUniformLocation(uniform);\r\n            let v = uniforms[uniform].value;\r\n            this.uniforms[uniform] = v;\r\n        }\r\n\r\n        this.bind();\r\n\r\n    }\r\n\r\n    bind()\r\n    {\r\n        this.gl.useProgram(this.program);\r\n    }\r\n\r\n    addUniformLocation(name)\r\n    {\r\n        this.cacheUniformsLocation[name] = this.gl.getUniformLocation(this.program, name);\r\n    }\r\n\r\n    getUniformLocation(name)\r\n    {\r\n        if(this.cacheUniformsLocation[name] !== undefined)\r\n        {\r\n            return this.cacheUniformsLocation[name];\r\n        }\r\n        else\r\n        {\r\n            this.addUniformLocation(name);\r\n\r\n            return this.getUniformLocation(name);\r\n        }\r\n    }\r\n\r\n    _checkIfBasicMatrices(uniforms)\r\n    {\r\n        let matrices = ['projectionMatrix', 'modelMatrix', 'viewMatrix'];\r\n\r\n        for (let i = 0; i < matrices.length; i++)\r\n        {\r\n            if(!uniforms[matrices[i]])\r\n            {\r\n                uniforms[matrices[i]] = {\r\n            \t\tvalue: mat4.create(),\r\n            \t\ttype: 'mat4'\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // create a this.uniforms property\r\n    // useful for the setter, we can just update the uniform when it gets changed\r\n    _createGetterSetterUniforms(uniforms)\r\n    {\r\n        let gl = this.gl;\r\n        let program = this.program;\r\n        let _this = this;\r\n\r\n        this.uniforms = new Proxy(uniforms, {\r\n            get: function(target, name)\r\n            {\r\n                if (!(name in target))\r\n                {\r\n                    console.log(\"Getting non-existant property '\" + name + \"'\");\r\n                    return undefined;\r\n                }\r\n\r\n                return target[name].value;\r\n            },\r\n            set: function(target, name, value)\r\n            {\r\n                if (!(name in target))\r\n                {\r\n                    console.log(\"Setting non-existant property '\" + name + \"', initial value: \" + value);\r\n\r\n                    return false;\r\n                }\r\n\r\n                // /!\\ TODO check Wen's GLShader.uniform() when it's not a number, seems more optimised\r\n                target[name].value = value;\r\n                let type = target[name].type;\r\n                let glFunction = POLY.CONST.uniformTypes[type];\r\n\r\n\r\n                if(type.indexOf('mat') === -1)\r\n                {\r\n                    if(type === 'texture')\r\n                    {\r\n                        gl[glFunction](_this.getUniformLocation(name), value, target[name].index);\r\n                    }\r\n                    else\r\n                    {\r\n                        gl[glFunction](_this.getUniformLocation(name), value);\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    gl[glFunction](_this.getUniformLocation(name), false, value);\r\n                }\r\n\r\n                return true;\r\n            }\r\n        });\r\n    }\r\n\r\n    addAttributeLocation(name)\r\n    {\r\n\r\n    //     if(shaderProgram.cacheAttribLoc === undefined) {\tshaderProgram.cacheAttribLoc = {};\t}\r\n\t// if(shaderProgram.cacheAttribLoc[name] === undefined) {\r\n\t// \tshaderProgram.cacheAttribLoc[name] = gl.getAttribLocation(shaderProgram, name);\r\n\t// }\r\n    //\r\n\t// return shaderProgram.cacheAttribLoc[name];\r\n        // console.log(this.cacheAttributesLocation[name], name);\r\n\r\n        if(this.cacheAttributesLocation[name] === undefined)\r\n        {\r\n            this.cacheAttributesLocation[name] = this.gl.getAttribLocation(this.program, name);\r\n        }\r\n    }\r\n\r\n    getAttributeLocation(name)\r\n    {\r\n        if(this.cacheAttributesLocation[name] !== undefined)\r\n        {\r\n            return this.cacheAttributesLocation[name];\r\n        }\r\n        else\r\n        {\r\n            this.addAttributeLocation(name);\r\n\r\n            return this.getAttributeLocation(name);\r\n        }\r\n    }\r\n\r\n    _attachShaders(vert, frag)\r\n    {\r\n        this.gl.attachShader(this.program, vert);\r\n        this.gl.attachShader(this.program, frag);\r\n    }\r\n\r\n    _createShader(src, isVertex)\r\n    {\r\n        let gl = this.gl;\r\n        let shader;\r\n        if (isVertex)\r\n        {\r\n            shader = gl.createShader(gl.VERTEX_SHADER);\r\n        }\r\n        else\r\n        {\r\n            shader = gl.createShader(gl.FRAGMENT_SHADER);\r\n        }\r\n\r\n        this.gl.shaderSource(shader, src);\r\n        this.gl.compileShader(shader);\r\n\r\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))\r\n        {\r\n            throw (\"Couldn't initialise shader, \", gl.getShaderInfoLog(shader));\r\n            return null;\r\n        }\r\n\r\n        return shader;\r\n    }\r\n}\r\n"]}