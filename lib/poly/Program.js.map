{"version":3,"sources":["../../src/poly/Program.js"],"names":["Program","vertShader","fragShader","uniforms","gl","POLY","cacheAttributesLocation","cacheUniformsLocation","program","createProgram","vert","_createShader","frag","_attachShaders","linkProgram","getProgramParameter","LINK_STATUS","useProgram","_createGetterSetterUniforms","uniform","addUniformLocation","v","value","bind","name","getUniformLocation","undefined","_this","Proxy","get","target","console","log","set","type","glFunction","CONST","uniformTypes","indexOf","index","getAttribLocation","addAttributeLocation","getAttributeLocation","attachShader","src","isVertex","shader","createShader","VERTEX_SHADER","FRAGMENT_SHADER","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog"],"mappings":";;;;;;;;;;IAAqBA,O;AAEjB,qBAAYC,UAAZ,EAAwBC,UAAxB,EAAoCC,QAApC,EACA;AAAA;;AACI,YAAIC,KAAKC,KAAKD,EAAd,CADJ,CACsB;AAClB,aAAKA,EAAL,GAAUA,EAAV;AACA;AACA,aAAKE,uBAAL,GAA+B,EAA/B;AACA,aAAKC,qBAAL,GAA6B,EAA7B;;AAEA;AACA,aAAKC,OAAL,GAAeJ,GAAGK,aAAH,EAAf;;AAEA,YAAIC,OAAO,KAAKC,aAAL,CAAmBV,UAAnB,EAA+B,IAA/B,CAAX;AACA,YAAIW,OAAO,KAAKD,aAAL,CAAmBT,UAAnB,EAA+B,KAA/B,CAAX;AACA,aAAKW,cAAL,CAAoBH,IAApB,EAA0BE,IAA1B;;AAEAR,WAAGU,WAAH,CAAe,KAAKN,OAApB;;AAEA;AACA,YAAI,CAACJ,GAAGW,mBAAH,CAAuB,KAAKP,OAA5B,EAAqCJ,GAAGY,WAAxC,CAAL,EACA;AACI,kBAAM,6BAAN;AACH;;AAEDZ,WAAGa,UAAH,CAAc,KAAKT,OAAnB;;AAEA,aAAKU,2BAAL,CAAiCf,QAAjC;AACA,aAAK,IAAIgB,OAAT,IAAoBhB,QAApB,EACA;AACI,iBAAKiB,kBAAL,CAAwBD,OAAxB;AACA,gBAAIE,IAAIlB,SAASgB,OAAT,EAAkBG,KAA1B;AACA,iBAAKnB,QAAL,CAAcgB,OAAd,IAAyBE,CAAzB;AACH;;AAED,aAAKE,IAAL;AAEH;;;;+BAGD;AACI,iBAAKnB,EAAL,CAAQa,UAAR,CAAmB,KAAKT,OAAxB;AACH;;;2CAEkBgB,I,EACnB;AACI,iBAAKjB,qBAAL,CAA2BiB,IAA3B,IAAmC,KAAKpB,EAAL,CAAQqB,kBAAR,CAA2B,KAAKjB,OAAhC,EAAyCgB,IAAzC,CAAnC;AACH;;;2CAEkBA,I,EACnB;AACI,gBAAG,KAAKjB,qBAAL,CAA2BiB,IAA3B,MAAqCE,SAAxC,EACA;AACI,uBAAO,KAAKnB,qBAAL,CAA2BiB,IAA3B,CAAP;AACH,aAHD,MAKA;AACI,qBAAKJ,kBAAL,CAAwBI,IAAxB;;AAEA,uBAAO,KAAKC,kBAAL,CAAwBD,IAAxB,CAAP;AACH;AACJ;;AAGD;AACA;;;;oDAC4BrB,Q,EAC5B;AACI,gBAAIC,KAAK,KAAKA,EAAd;AACA,gBAAII,UAAU,KAAKA,OAAnB;AACA,gBAAImB,QAAQ,IAAZ;;AAEA,iBAAKxB,QAAL,GAAgB,IAAIyB,KAAJ,CAAUzB,QAAV,EAAoB;AAChC0B,qBAAK,aAASC,MAAT,EAAiBN,IAAjB,EACL;AACI,wBAAI,EAAEA,QAAQM,MAAV,CAAJ,EACA;AACIC,gCAAQC,GAAR,CAAY,oCAAoCR,IAApC,GAA2C,GAAvD;AACA,+BAAOE,SAAP;AACH;;AAED,2BAAOI,OAAON,IAAP,EAAaF,KAApB;AACH,iBAV+B;AAWhCW,qBAAK,aAASH,MAAT,EAAiBN,IAAjB,EAAuBF,KAAvB,EACL;AACI,wBAAI,EAAEE,QAAQM,MAAV,CAAJ,EACA;AACIC,gCAAQC,GAAR,CAAY,oCAAoCR,IAApC,GAA2C,oBAA3C,GAAkEF,KAA9E;;AAEA,+BAAO,KAAP;AACH;;AAED;AACAQ,2BAAON,IAAP,EAAaF,KAAb,GAAqBA,KAArB;AACA,wBAAIY,OAAOJ,OAAON,IAAP,EAAaU,IAAxB;AACA,wBAAIC,aAAa9B,KAAK+B,KAAL,CAAWC,YAAX,CAAwBH,IAAxB,CAAjB;;AAGA,wBAAGA,KAAKI,OAAL,CAAa,KAAb,MAAwB,CAAC,CAA5B,EACA;AACI,4BAAGJ,SAAS,SAAZ,EACA;AACI9B,+BAAG+B,UAAH,EAAeR,MAAMF,kBAAN,CAAyBD,IAAzB,CAAf,EAA+CF,KAA/C,EAAsDQ,OAAON,IAAP,EAAae,KAAnE;AACH,yBAHD,MAKA;AACInC,+BAAG+B,UAAH,EAAeR,MAAMF,kBAAN,CAAyBD,IAAzB,CAAf,EAA+CF,KAA/C;AACH;AACJ,qBAVD,MAYA;AACIlB,2BAAG+B,UAAH,EAAeR,MAAMF,kBAAN,CAAyBD,IAAzB,CAAf,EAA+C,KAA/C,EAAsDF,KAAtD;AACH;;AAED,2BAAO,IAAP;AACH;AA3C+B,aAApB,CAAhB;AA6CH;;;6CAEoBE,I,EACrB;;AAEA;AACH;AACA;AACA;AACG;AACH;AACO;;AAEA,gBAAG,KAAKlB,uBAAL,CAA6BkB,IAA7B,MAAuCE,SAA1C,EACA;AACI,qBAAKpB,uBAAL,CAA6BkB,IAA7B,IAAqC,KAAKpB,EAAL,CAAQoC,iBAAR,CAA0B,KAAKhC,OAA/B,EAAwCgB,IAAxC,CAArC;AACH;AACJ;;;6CAEoBA,I,EACrB;AACI,gBAAG,KAAKlB,uBAAL,CAA6BkB,IAA7B,MAAuCE,SAA1C,EACA;AACI,uBAAO,KAAKpB,uBAAL,CAA6BkB,IAA7B,CAAP;AACH,aAHD,MAKA;AACI,qBAAKiB,oBAAL,CAA0BjB,IAA1B;;AAEA,uBAAO,KAAKkB,oBAAL,CAA0BlB,IAA1B,CAAP;AACH;AACJ;;;uCAEcd,I,EAAME,I,EACrB;AACI,iBAAKR,EAAL,CAAQuC,YAAR,CAAqB,KAAKnC,OAA1B,EAAmCE,IAAnC;AACA,iBAAKN,EAAL,CAAQuC,YAAR,CAAqB,KAAKnC,OAA1B,EAAmCI,IAAnC;AACH;;;sCAEagC,G,EAAKC,Q,EACnB;AACI,gBAAIzC,KAAK,KAAKA,EAAd;AACA,gBAAI0C,eAAJ;AACA,gBAAID,QAAJ,EACA;AACIC,yBAAS1C,GAAG2C,YAAH,CAAgB3C,GAAG4C,aAAnB,CAAT;AACH,aAHD,MAKA;AACIF,yBAAS1C,GAAG2C,YAAH,CAAgB3C,GAAG6C,eAAnB,CAAT;AACH;;AAED,iBAAK7C,EAAL,CAAQ8C,YAAR,CAAqBJ,MAArB,EAA6BF,GAA7B;AACA,iBAAKxC,EAAL,CAAQ+C,aAAR,CAAsBL,MAAtB;;AAEA,gBAAI,CAAC1C,GAAGgD,kBAAH,CAAsBN,MAAtB,EAA8B1C,GAAGiD,cAAjC,CAAL,EACA;AACI,sBAAO,gCAAgCjD,GAAGkD,gBAAH,CAAoBR,MAApB,CAAvC;AACA,uBAAO,IAAP;AACH;;AAED,mBAAOA,MAAP;AACH;;;;;;kBAnLgB9C,O","file":"Program.js","sourcesContent":["export default class Program\n{\n    constructor(vertShader, fragShader, uniforms)\n    {\n        let gl = POLY.gl; // not sure that's great... :p\n        this.gl = gl;\n        // cache the locations of attributes and uniforms\n        this.cacheAttributesLocation = {}\n        this.cacheUniformsLocation = {}\n\n        // create the program itself\n        this.program = gl.createProgram();\n\n        let vert = this._createShader(vertShader, true);\n        let frag = this._createShader(fragShader, false);\n        this._attachShaders(vert, frag);\n\n        gl.linkProgram(this.program);\n\n        // check for errors\n        if (!gl.getProgramParameter(this.program, gl.LINK_STATUS))\n        {\n            throw \"Couldn't initialise program\";\n        }\n\n        gl.useProgram(this.program);\n\n        this._createGetterSetterUniforms(uniforms);\n        for (let uniform in uniforms)\n        {\n            this.addUniformLocation(uniform);\n            let v = uniforms[uniform].value;\n            this.uniforms[uniform] = v;\n        }\n\n        this.bind();\n\n    }\n\n    bind()\n    {\n        this.gl.useProgram(this.program);\n    }\n\n    addUniformLocation(name)\n    {\n        this.cacheUniformsLocation[name] = this.gl.getUniformLocation(this.program, name);\n    }\n\n    getUniformLocation(name)\n    {\n        if(this.cacheUniformsLocation[name] !== undefined)\n        {\n            return this.cacheUniformsLocation[name];\n        }\n        else\n        {\n            this.addUniformLocation(name);\n\n            return this.getUniformLocation(name);\n        }\n    }\n\n\n    // create a this.uniforms property\n    // useful for the setter, we can just update the uniform when it gets changed\n    _createGetterSetterUniforms(uniforms)\n    {\n        let gl = this.gl;\n        let program = this.program;\n        let _this = this;\n\n        this.uniforms = new Proxy(uniforms, {\n            get: function(target, name)\n            {\n                if (!(name in target))\n                {\n                    console.log(\"Getting non-existant property '\" + name + \"'\");\n                    return undefined;\n                }\n\n                return target[name].value;\n            },\n            set: function(target, name, value)\n            {\n                if (!(name in target))\n                {\n                    console.log(\"Setting non-existant property '\" + name + \"', initial value: \" + value);\n\n                    return false;\n                }\n\n                // /!\\ TODO check Wen's GLShader.uniform() when it's not a number, seems more optimised\n                target[name].value = value;\n                let type = target[name].type;\n                let glFunction = POLY.CONST.uniformTypes[type];\n\n\n                if(type.indexOf('mat') === -1)\n                {\n                    if(type === 'texture')\n                    {\n                        gl[glFunction](_this.getUniformLocation(name), value, target[name].index);\n                    }\n                    else\n                    {\n                        gl[glFunction](_this.getUniformLocation(name), value);\n                    }\n                }\n                else\n                {\n                    gl[glFunction](_this.getUniformLocation(name), false, value);\n                }\n\n                return true;\n            }\n        });\n    }\n\n    addAttributeLocation(name)\n    {\n\n    //     if(shaderProgram.cacheAttribLoc === undefined) {\tshaderProgram.cacheAttribLoc = {};\t}\n\t// if(shaderProgram.cacheAttribLoc[name] === undefined) {\n\t// \tshaderProgram.cacheAttribLoc[name] = gl.getAttribLocation(shaderProgram, name);\n\t// }\n    //\n\t// return shaderProgram.cacheAttribLoc[name];\n        // console.log(this.cacheAttributesLocation[name], name);\n\n        if(this.cacheAttributesLocation[name] === undefined)\n        {\n            this.cacheAttributesLocation[name] = this.gl.getAttribLocation(this.program, name);\n        }\n    }\n\n    getAttributeLocation(name)\n    {\n        if(this.cacheAttributesLocation[name] !== undefined)\n        {\n            return this.cacheAttributesLocation[name];\n        }\n        else\n        {\n            this.addAttributeLocation(name);\n\n            return this.getAttributeLocation(name);\n        }\n    }\n\n    _attachShaders(vert, frag)\n    {\n        this.gl.attachShader(this.program, vert);\n        this.gl.attachShader(this.program, frag);\n    }\n\n    _createShader(src, isVertex)\n    {\n        let gl = this.gl;\n        let shader;\n        if (isVertex)\n        {\n            shader = gl.createShader(gl.VERTEX_SHADER);\n        }\n        else\n        {\n            shader = gl.createShader(gl.FRAGMENT_SHADER);\n        }\n\n        this.gl.shaderSource(shader, src);\n        this.gl.compileShader(shader);\n\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))\n        {\n            throw (\"Couldn't initialise shader, \", gl.getShaderInfoLog(shader));\n            return null;\n        }\n\n        return shader;\n    }\n}\n"]}